package com.pingpal.ui;

import com.pingpal.datavalidation.ValidationUtils;
import com.pingpal.deviceping.DevicePing;
import com.pingpal.deviceping.DevicePingResult;
import com.pingpal.exceptions.imports.InvalidScanTypeException;
import com.pingpal.exceptions.ui.BlankFieldException;
import com.pingpal.exceptions.ui.InvalidIPAddressException;
import com.pingpal.exceptions.ui.InvalidNetworkRangeException;
import com.pingpal.exceptions.ui.InvalidPortRangeException;
import com.pingpal.exports.ExportResults;
import com.pingpal.imports.ImportResults;
import com.pingpal.imports.ImportResultsListener;
import com.pingpal.portscan.PortScan;
import com.pingpal.portscan.PortScanResult;
import com.pingpal.subnetscan.SubnetScan;
import com.pingpal.subnetscan.SubnetScanResult;
import com.pingpal.tcpmessage.connect.TCPMessageConnect;
import com.pingpal.tcpmessage.listen.TCPMessageListen;
import java.awt.CardLayout;
import java.awt.Color;
import static java.awt.EventQueue.invokeLater;
import java.util.ArrayList;
import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;

/**
 * The main application window.
 * <p>
 * Uses a {@code CardLayout} to switch between panels for subnet-scan,
 * device-ping, port-scan, TCP messaging, import/export, and help screens.
 * </p>
 * <p>
 * Inherits the properties of the {@code javax.swing.JFrame} class.
 * </p>
 * <p>
 * Implements the properties of the {@code ImportResultsListener} class.
 * </p>
 */
public class HomePage extends javax.swing.JFrame implements ImportResultsListener {

    // The card layout responsible for managing all of the different cards containing the different scans.
    private static CardLayout card;

    // Flag indicating whether the TCP message funciton was used last.
    private boolean tcpMessageLast = true;
    // Flag indicating whether the TCP message listen function was used last.    
    private boolean listenLast = false;

    // Network range text field default text constant.
    private final String DEFAULT_NETWORK_RANGE_TEXT = "e.g. 192.168.0.0/24";
    // IP address text field default text constant.
    private final String DEFAULT_IP_ADDRESS_TEXT = "e.g. 192.168.0.1";

    // Flag indicating if a subnect scan is in progress.
    private boolean subnetScanInProgress = false;
    // Thread used to execute a subnet scan.
    private Thread subnetScanThread;
    // Subnet scan object containing all the functionality.
    private SubnetScan subnetScan;

    // Flag indicating if a device ping is in progress.
    private boolean devicePingInProgress = false;
    // Thread used to execute a device ping.
    private Thread devicePingThread;
    // Device ping object containing all the functionality.
    private DevicePing devicePing;

    // Flag indicating if a port scan is in progress.
    private boolean portScanInProgress = false;
    // Thread used to execute a port scan.
    private Thread portScanThread;
    // Port scan object containing all of the functionality.
    private PortScan portScan;

    // Flag indicating if a TCP message listen is in progress.
    private boolean tcpMessageListenInProgress = false;
    // Thread used to execute a TCP message listen.
    private Thread tcpMessageListenThread;
    // TCP message listen object containing all of the functionality.
    private TCPMessageListen tcpMessageListen;

    // Flag indicating if a TCP message connect is in progress.
    private boolean tcpMessageConnectInProgress = false;
    // Thread used to execute a TCP message connect.
    private Thread tcpMessageConnectThread;
    // TCP message connect object containing all of the functionality.
    private TCPMessageConnect tcpMessageConnect;

    /**
     * Creates new form HomePage
     */
    public HomePage() {
        // Initialise components.
        initComponents();

        // Set window properties.
        this.setLocationRelativeTo(null);
        this.setResizable(false);

        // Set app icon.
        ImageIcon icon = new ImageIcon(".\\src\\com\\pingpal\\resources\\images\\icon.png");
        this.setIconImage(icon.getImage());

        // Initialise card layout.
        card = (CardLayout) pnlMainPanel.getLayout();
        card.show(pnlMainPanel, "pnlMainPage");
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pnlHomePage = new javax.swing.JPanel();
        pnlSideBar = new javax.swing.JPanel();
        lblTitle = new javax.swing.JLabel();
        pnlLine1 = new javax.swing.JPanel();
        btnSubnetScan = new javax.swing.JButton();
        lblNetworking = new javax.swing.JLabel();
        btnDevicePing = new javax.swing.JButton();
        btnPortScan = new javax.swing.JButton();
        btnTCPMessage = new javax.swing.JButton();
        btnImportResults = new javax.swing.JButton();
        btnTCPMessageListen = new javax.swing.JButton();
        btnTCPMessageConnect = new javax.swing.JButton();
        pnlMainPanel = new javax.swing.JPanel();
        lblNoTabsOpen = new javax.swing.JLabel();
        pnlSubnetScan = new javax.swing.JPanel();
        lblSubnetScan = new javax.swing.JLabel();
        lblNetworkRange = new javax.swing.JLabel();
        txfNetworkRange = new javax.swing.JTextField();
        btnStartSubnetScan = new javax.swing.JButton();
        scrSubnetScan = new javax.swing.JScrollPane();
        tblSubnetScan = new javax.swing.JTable();
        btnExportResultsSubnetScan = new javax.swing.JButton();
        lblSubnetScanInProgress = new javax.swing.JLabel();
        lblTimeoutSubnetScan = new javax.swing.JLabel();
        spnTimeoutSubnetScan = new javax.swing.JSpinner();
        lblNetworkRangeError = new javax.swing.JLabel();
        prgSubnetScan = new javax.swing.JProgressBar();
        pnlPortScan = new javax.swing.JPanel();
        lblPortScan = new javax.swing.JLabel();
        txfIPAddressPortScan = new javax.swing.JTextField();
        btnStartPortScan = new javax.swing.JButton();
        spnBottomRangePort = new javax.swing.JSpinner();
        spnTopRangePort = new javax.swing.JSpinner();
        lblIPAdressPortScan = new javax.swing.JLabel();
        lblDash = new javax.swing.JLabel();
        lblPortRange = new javax.swing.JLabel();
        scrPortScan = new javax.swing.JScrollPane();
        tblPortScan = new javax.swing.JTable();
        btnExportResultsPortScan = new javax.swing.JButton();
        lblPortRangeError = new javax.swing.JLabel();
        lblIPAddressErrorPortScan = new javax.swing.JLabel();
        lblPortScanInProgress = new javax.swing.JLabel();
        lblTimeoutPortScan = new javax.swing.JLabel();
        spnTimeoutPortScan = new javax.swing.JSpinner();
        prgPortScan = new javax.swing.JProgressBar();
        pnlTCPMessageListen = new javax.swing.JPanel();
        lblTCPMessageListen = new javax.swing.JLabel();
        lblPortTCPMessageListen = new javax.swing.JLabel();
        spnPortTCPMessageListen = new javax.swing.JSpinner();
        btnStartTCPMessageListen = new javax.swing.JButton();
        lblTCPMessageListenInProgress = new javax.swing.JLabel();
        btnExportResultsTCPMessageListen = new javax.swing.JButton();
        btnSendTCPMessageListen = new javax.swing.JButton();
        lblEnterMessageTCPMessageListen = new javax.swing.JLabel();
        scrTCPMessageListen = new javax.swing.JScrollPane();
        txpTCPMessageListen = new javax.swing.JTextPane();
        txfMessageTCPMessageListen = new javax.swing.JTextField();
        pnlDevicePing = new javax.swing.JPanel();
        lblDevicePing = new javax.swing.JLabel();
        lblIPAddressDevicePing = new javax.swing.JLabel();
        lblPingInterval = new javax.swing.JLabel();
        spnPingInterval = new javax.swing.JSpinner();
        txfIPAddressDevicePing = new javax.swing.JTextField();
        lblContinuousPinging = new javax.swing.JLabel();
        chkContinuousPinging = new javax.swing.JCheckBox();
        lblNumberOfPings = new javax.swing.JLabel();
        spnNumberOfPings = new javax.swing.JSpinner();
        btnStartDevicePing = new javax.swing.JButton();
        scrDevicePing = new javax.swing.JScrollPane();
        tblDevicePing = new javax.swing.JTable();
        btnExportResultsDevicePing = new javax.swing.JButton();
        lblIPAddressErrorDevicePing = new javax.swing.JLabel();
        lblDevicePingInProgress = new javax.swing.JLabel();
        scrDevicePingPacketResults = new javax.swing.JScrollPane();
        tblDevicePingPacketResults = new javax.swing.JTable();
        scrDevicePingResponseResults = new javax.swing.JScrollPane();
        tblDevicePingResponseResults = new javax.swing.JTable();
        pnlTCPMessageConnect = new javax.swing.JPanel();
        lblTCPMessageConnect = new javax.swing.JLabel();
        lblPortTCPMessageConnect = new javax.swing.JLabel();
        lblIPAddressTCPMessageConnect = new javax.swing.JLabel();
        txfIPAddressTCPMessageConnect = new javax.swing.JTextField();
        spnPortTCPMessageConnect = new javax.swing.JSpinner();
        btnStartTCPMessageConnect = new javax.swing.JButton();
        lblIPAddressErrorTCPMessageConnect = new javax.swing.JLabel();
        lblTCPMessageConnectInProgress = new javax.swing.JLabel();
        scrTCPMessageConnect = new javax.swing.JScrollPane();
        txpTCPMessageConnect = new javax.swing.JTextPane();
        lblEnterMessageTCPMessageConnect = new javax.swing.JLabel();
        txfMessageTCPMessageConnect = new javax.swing.JTextField();
        btnSendTCPMessageConnect = new javax.swing.JButton();
        btnExportResultsTCPMessageConnect = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("PingPal");
        setBackground(new java.awt.Color(0, 255, 204));
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setName("HomePage"); // NOI18N

        pnlHomePage.setBackground(new java.awt.Color(49, 49, 49));
        pnlHomePage.setForeground(new java.awt.Color(215, 215, 215));
        pnlHomePage.setName("PingPal"); // NOI18N
        pnlHomePage.setPreferredSize(new java.awt.Dimension(0, 0));
        pnlHomePage.setVerifyInputWhenFocusTarget(false);

        pnlSideBar.setBackground(new java.awt.Color(45, 45, 45));
        pnlSideBar.setPreferredSize(new java.awt.Dimension(280, 720));

        lblTitle.setFont(new java.awt.Font("Dubai Medium", 1, 64)); // NOI18N
        lblTitle.setForeground(new java.awt.Color(233, 247, 249));
        lblTitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblTitle.setText("PingPal");
        lblTitle.setFocusable(false);
        lblTitle.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        lblTitle.setMaximumSize(new java.awt.Dimension(215, 110));
        lblTitle.setMinimumSize(new java.awt.Dimension(215, 110));
        lblTitle.setPreferredSize(new java.awt.Dimension(215, 110));

        pnlLine1.setBackground(new java.awt.Color(233, 247, 249));
        pnlLine1.setFocusable(false);
        pnlLine1.setPreferredSize(new java.awt.Dimension(270, 2));

        javax.swing.GroupLayout pnlLine1Layout = new javax.swing.GroupLayout(pnlLine1);
        pnlLine1.setLayout(pnlLine1Layout);
        pnlLine1Layout.setHorizontalGroup(
            pnlLine1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 270, Short.MAX_VALUE)
        );
        pnlLine1Layout.setVerticalGroup(
            pnlLine1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 2, Short.MAX_VALUE)
        );

        btnSubnetScan.setBackground(new java.awt.Color(45, 45, 45));
        btnSubnetScan.setFont(new java.awt.Font("Dubai Medium", 0, 16)); // NOI18N
        btnSubnetScan.setForeground(new java.awt.Color(233, 247, 249));
        btnSubnetScan.setText("Subnet Scan");
        btnSubnetScan.setBorder(null);
        btnSubnetScan.setBorderPainted(false);
        btnSubnetScan.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnSubnetScan.setFocusPainted(false);
        btnSubnetScan.setHorizontalAlignment(javax.swing.SwingConstants.LEADING);
        btnSubnetScan.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSubnetScanActionPerformed(evt);
            }
        });

        lblNetworking.setFont(new java.awt.Font("Dubai Medium", 1, 18)); // NOI18N
        lblNetworking.setForeground(new java.awt.Color(233, 247, 249));
        lblNetworking.setText("Networking");
        lblNetworking.setFocusable(false);

        btnDevicePing.setBackground(new java.awt.Color(45, 45, 45));
        btnDevicePing.setFont(new java.awt.Font("Dubai Medium", 0, 16)); // NOI18N
        btnDevicePing.setForeground(new java.awt.Color(233, 247, 249));
        btnDevicePing.setText("Device Ping");
        btnDevicePing.setBorder(null);
        btnDevicePing.setBorderPainted(false);
        btnDevicePing.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnDevicePing.setFocusPainted(false);
        btnDevicePing.setHorizontalAlignment(javax.swing.SwingConstants.LEADING);
        btnDevicePing.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDevicePingActionPerformed(evt);
            }
        });

        btnPortScan.setBackground(new java.awt.Color(45, 45, 45));
        btnPortScan.setFont(new java.awt.Font("Dubai Medium", 0, 16)); // NOI18N
        btnPortScan.setForeground(new java.awt.Color(233, 247, 249));
        btnPortScan.setText("Port Scan");
        btnPortScan.setBorder(null);
        btnPortScan.setBorderPainted(false);
        btnPortScan.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnPortScan.setFocusPainted(false);
        btnPortScan.setHorizontalAlignment(javax.swing.SwingConstants.LEADING);
        btnPortScan.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnPortScanActionPerformed(evt);
            }
        });

        btnTCPMessage.setBackground(new java.awt.Color(45, 45, 45));
        btnTCPMessage.setFont(new java.awt.Font("Dubai Medium", 0, 16)); // NOI18N
        btnTCPMessage.setForeground(new java.awt.Color(233, 247, 249));
        btnTCPMessage.setText("TCP Message");
        btnTCPMessage.setBorder(null);
        btnTCPMessage.setBorderPainted(false);
        btnTCPMessage.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnTCPMessage.setFocusPainted(false);
        btnTCPMessage.setHorizontalAlignment(javax.swing.SwingConstants.LEADING);
        btnTCPMessage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnTCPMessageActionPerformed(evt);
            }
        });

        btnImportResults.setBackground(new java.awt.Color(45, 45, 45));
        btnImportResults.setFont(new java.awt.Font("Dubai Medium", 0, 16)); // NOI18N
        btnImportResults.setForeground(new java.awt.Color(233, 247, 249));
        btnImportResults.setText("Import Results");
        btnImportResults.setBorder(null);
        btnImportResults.setBorderPainted(false);
        btnImportResults.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnImportResults.setFocusPainted(false);
        btnImportResults.setHorizontalAlignment(javax.swing.SwingConstants.LEADING);
        btnImportResults.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnImportResultsActionPerformed(evt);
            }
        });

        btnTCPMessageListen.setBackground(new java.awt.Color(45, 45, 45));
        btnTCPMessageListen.setFont(new java.awt.Font("Dubai", 0, 14)); // NOI18N
        btnTCPMessageListen.setForeground(new java.awt.Color(233, 247, 249));
        btnTCPMessageListen.setText("-  Listen");
        btnTCPMessageListen.setBorder(null);
        btnTCPMessageListen.setBorderPainted(false);
        btnTCPMessageListen.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnTCPMessageListen.setFocusPainted(false);
        btnTCPMessageListen.setHorizontalAlignment(javax.swing.SwingConstants.LEADING);
        btnTCPMessageListen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnTCPMessageListenActionPerformed(evt);
            }
        });

        btnTCPMessageConnect.setBackground(new java.awt.Color(45, 45, 45));
        btnTCPMessageConnect.setFont(new java.awt.Font("Dubai", 0, 14)); // NOI18N
        btnTCPMessageConnect.setForeground(new java.awt.Color(233, 247, 249));
        btnTCPMessageConnect.setText("-  Connect");
        btnTCPMessageConnect.setBorder(null);
        btnTCPMessageConnect.setBorderPainted(false);
        btnTCPMessageConnect.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        btnTCPMessageConnect.setFocusPainted(false);
        btnTCPMessageConnect.setHorizontalAlignment(javax.swing.SwingConstants.LEADING);
        btnTCPMessageConnect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnTCPMessageConnectActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout pnlSideBarLayout = new javax.swing.GroupLayout(pnlSideBar);
        pnlSideBar.setLayout(pnlSideBarLayout);
        pnlSideBarLayout.setHorizontalGroup(
            pnlSideBarLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlSideBarLayout.createSequentialGroup()
                .addGroup(pnlSideBarLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(pnlSideBarLayout.createSequentialGroup()
                        .addGap(5, 5, 5)
                        .addComponent(pnlLine1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(pnlSideBarLayout.createSequentialGroup()
                        .addGap(30, 30, 30)
                        .addGroup(pnlSideBarLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblTitle, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(pnlSideBarLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(btnSubnetScan, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(btnDevicePing, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(btnPortScan, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(btnTCPMessage, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 126, Short.MAX_VALUE))))
                    .addGroup(pnlSideBarLayout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(lblNetworking))
                    .addGroup(pnlSideBarLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addGroup(pnlSideBarLayout.createSequentialGroup()
                            .addContainerGap()
                            .addComponent(btnImportResults, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, pnlSideBarLayout.createSequentialGroup()
                            .addGap(46, 46, 46)
                            .addGroup(pnlSideBarLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(btnTCPMessageConnect, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(btnTCPMessageListen, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        pnlSideBarLayout.setVerticalGroup(
            pnlSideBarLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlSideBarLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lblTitle, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(30, 30, 30)
                .addComponent(lblNetworking, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(1, 1, 1)
                .addComponent(pnlLine1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(20, 20, 20)
                .addComponent(btnSubnetScan, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(12, 12, 12)
                .addComponent(btnDevicePing, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(12, 12, 12)
                .addComponent(btnPortScan, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(12, 12, 12)
                .addComponent(btnTCPMessage, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(btnTCPMessageListen)
                .addGap(2, 2, 2)
                .addComponent(btnTCPMessageConnect)
                .addGap(12, 12, 12)
                .addComponent(btnImportResults, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pnlMainPanel.setBackground(new java.awt.Color(49, 49, 49));
        pnlMainPanel.setPreferredSize(new java.awt.Dimension(1000, 720));
        pnlMainPanel.setLayout(new java.awt.CardLayout());

        lblNoTabsOpen.setFont(new java.awt.Font("Dubai Medium", 0, 36)); // NOI18N
        lblNoTabsOpen.setForeground(new java.awt.Color(70, 70, 70));
        lblNoTabsOpen.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblNoTabsOpen.setText("No tab open");
        lblNoTabsOpen.setPreferredSize(new java.awt.Dimension(270, 82));
        pnlMainPanel.add(lblNoTabsOpen, "card3");

        pnlSubnetScan.setBackground(new java.awt.Color(49, 49, 49));

        lblSubnetScan.setFont(new java.awt.Font("Dubai Medium", 1, 24)); // NOI18N
        lblSubnetScan.setForeground(new java.awt.Color(233, 247, 249));
        lblSubnetScan.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblSubnetScan.setText("Subnet Scan");

        lblNetworkRange.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblNetworkRange.setForeground(new java.awt.Color(233, 247, 249));
        lblNetworkRange.setText("Enter the network range:");

        txfNetworkRange.setBackground(new java.awt.Color(255, 255, 255));
        txfNetworkRange.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        txfNetworkRange.setForeground(new java.awt.Color(45, 45, 45));
        txfNetworkRange.setText(DEFAULT_NETWORK_RANGE_TEXT);
        txfNetworkRange.setToolTipText("Range of devices to scan.");
        txfNetworkRange.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 5, 1, 1));
        txfNetworkRange.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                txfNetworkRangeFocusGained(evt);
            }
        });

        btnStartSubnetScan.setBackground(new java.awt.Color(45, 45, 45));
        btnStartSubnetScan.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        btnStartSubnetScan.setForeground(new java.awt.Color(233, 247, 249));
        btnStartSubnetScan.setText("Start Subnet Scan");
        btnStartSubnetScan.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btnStartSubnetScan.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnStartSubnetScanActionPerformed(evt);
            }
        });

        tblSubnetScan.setBackground(new java.awt.Color(255, 255, 255));
        tblSubnetScan.setForeground(new java.awt.Color(45, 45, 45));
        tblSubnetScan.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "IP Address"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tblSubnetScan.setRowMargin(4);
        tblSubnetScan.setSelectionForeground(new java.awt.Color(233, 247, 249));
        tblSubnetScan.getTableHeader().setReorderingAllowed(false);
        scrSubnetScan.setViewportView(tblSubnetScan);

        btnExportResultsSubnetScan.setBackground(new java.awt.Color(45, 45, 45));
        btnExportResultsSubnetScan.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        btnExportResultsSubnetScan.setForeground(new java.awt.Color(233, 247, 249));
        btnExportResultsSubnetScan.setText("Export Results");
        btnExportResultsSubnetScan.setToolTipText("Exports the results to a JSON file.");
        btnExportResultsSubnetScan.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btnExportResultsSubnetScan.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExportResultsSubnetScanActionPerformed(evt);
            }
        });

        lblSubnetScanInProgress.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblSubnetScanInProgress.setForeground(new java.awt.Color(0, 204, 0));

        lblTimeoutSubnetScan.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblTimeoutSubnetScan.setForeground(new java.awt.Color(233, 247, 249));
        lblTimeoutSubnetScan.setText("Timeout after (ms):");

        spnTimeoutSubnetScan.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        spnTimeoutSubnetScan.setModel(new javax.swing.SpinnerNumberModel(500, 100, 10000, 1));
        spnTimeoutSubnetScan.setToolTipText("How long the scan waits for a response.");
        spnTimeoutSubnetScan.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        spnTimeoutSubnetScan.setPreferredSize(new java.awt.Dimension(104, 23));

        lblNetworkRangeError.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblNetworkRangeError.setForeground(new java.awt.Color(255, 51, 0));

        prgSubnetScan.setBackground(new java.awt.Color(255, 255, 255));
        prgSubnetScan.setFont(new java.awt.Font("Dubai", 0, 10)); // NOI18N
        prgSubnetScan.setForeground(new java.awt.Color(0, 204, 0));
        prgSubnetScan.setName(""); // NOI18N
        prgSubnetScan.setStringPainted(true);

        javax.swing.GroupLayout pnlSubnetScanLayout = new javax.swing.GroupLayout(pnlSubnetScan);
        pnlSubnetScan.setLayout(pnlSubnetScanLayout);
        pnlSubnetScanLayout.setHorizontalGroup(
            pnlSubnetScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(lblSubnetScan, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlSubnetScanLayout.createSequentialGroup()
                .addGap(30, 30, 30)
                .addGroup(pnlSubnetScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(prgSubnetScan, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(pnlSubnetScanLayout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(btnExportResultsSubnetScan, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(scrSubnetScan)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, pnlSubnetScanLayout.createSequentialGroup()
                        .addGroup(pnlSubnetScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblNetworkRange)
                            .addComponent(lblTimeoutSubnetScan))
                        .addGap(18, 18, 18)
                        .addGroup(pnlSubnetScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(pnlSubnetScanLayout.createSequentialGroup()
                                .addComponent(btnStartSubnetScan, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(lblSubnetScanInProgress, javax.swing.GroupLayout.PREFERRED_SIZE, 614, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(pnlSubnetScanLayout.createSequentialGroup()
                                .addGroup(pnlSubnetScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(txfNetworkRange, javax.swing.GroupLayout.DEFAULT_SIZE, 140, Short.MAX_VALUE)
                                    .addComponent(spnTimeoutSubnetScan, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addGap(18, 18, 18)
                                .addComponent(lblNetworkRangeError, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))))
                .addGap(30, 30, 30))
        );
        pnlSubnetScanLayout.setVerticalGroup(
            pnlSubnetScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlSubnetScanLayout.createSequentialGroup()
                .addGap(36, 36, 36)
                .addComponent(lblSubnetScan)
                .addGap(18, 18, 18)
                .addGroup(pnlSubnetScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(pnlSubnetScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(lblNetworkRange)
                        .addComponent(txfNetworkRange, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(lblNetworkRangeError, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(pnlSubnetScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(lblTimeoutSubnetScan)
                    .addComponent(spnTimeoutSubnetScan, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(pnlSubnetScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(lblSubnetScanInProgress, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(pnlSubnetScanLayout.createSequentialGroup()
                        .addComponent(btnStartSubnetScan)
                        .addGap(30, 30, 30)
                        .addComponent(scrSubnetScan, javax.swing.GroupLayout.PREFERRED_SIZE, 349, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(18, 18, 18)
                .addComponent(prgSubnetScan, javax.swing.GroupLayout.PREFERRED_SIZE, 18, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(30, 30, 30)
                .addComponent(btnExportResultsSubnetScan, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(45, Short.MAX_VALUE))
        );

        pnlMainPanel.add(pnlSubnetScan, "cardSubnetScan");

        pnlPortScan.setBackground(new java.awt.Color(49, 49, 49));
        pnlPortScan.setMaximumSize(new java.awt.Dimension(1000, 720));
        pnlPortScan.setMinimumSize(new java.awt.Dimension(1000, 720));

        lblPortScan.setFont(new java.awt.Font("Dubai Medium", 1, 24)); // NOI18N
        lblPortScan.setForeground(new java.awt.Color(233, 247, 249));
        lblPortScan.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblPortScan.setText("Port Scan");
        lblPortScan.setMaximumSize(new java.awt.Dimension(1000, 42));
        lblPortScan.setMinimumSize(new java.awt.Dimension(1000, 42));
        lblPortScan.setPreferredSize(new java.awt.Dimension(1000, 42));

        txfIPAddressPortScan.setBackground(new java.awt.Color(255, 255, 255));
        txfIPAddressPortScan.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        txfIPAddressPortScan.setForeground(new java.awt.Color(45, 45, 45));
        txfIPAddressPortScan.setText(DEFAULT_IP_ADDRESS_TEXT);
        txfIPAddressPortScan.setToolTipText("The device to scan.");
        txfIPAddressPortScan.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 5, 1, 1));
        txfIPAddressPortScan.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                txfIPAddressPortScanFocusGained(evt);
            }
        });

        btnStartPortScan.setBackground(new java.awt.Color(45, 45, 45));
        btnStartPortScan.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        btnStartPortScan.setForeground(new java.awt.Color(233, 247, 249));
        btnStartPortScan.setText("Start Port Scan");
        btnStartPortScan.setToolTipText("");
        btnStartPortScan.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btnStartPortScan.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnStartPortScanActionPerformed(evt);
            }
        });

        spnBottomRangePort.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        spnBottomRangePort.setModel(new javax.swing.SpinnerNumberModel(1, 1, 65535, 1));
        spnBottomRangePort.setToolTipText("The port to start scanning from.");
        spnBottomRangePort.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        spnBottomRangePort.setPreferredSize(new java.awt.Dimension(104, 23));

        spnTopRangePort.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        spnTopRangePort.setModel(new javax.swing.SpinnerNumberModel(1023, 1, 65535, 1));
        spnTopRangePort.setToolTipText("The port to scan until.");
        spnTopRangePort.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        spnTopRangePort.setPreferredSize(new java.awt.Dimension(104, 23));

        lblIPAdressPortScan.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblIPAdressPortScan.setForeground(new java.awt.Color(233, 247, 249));
        lblIPAdressPortScan.setText("Enter the IP address:");

        lblDash.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblDash.setForeground(new java.awt.Color(233, 247, 249));
        lblDash.setText("-");

        lblPortRange.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblPortRange.setForeground(new java.awt.Color(233, 247, 249));
        lblPortRange.setText("Enter the range of ports:");

        tblPortScan.setBackground(new java.awt.Color(255, 255, 255));
        tblPortScan.setForeground(new java.awt.Color(45, 45, 45));
        tblPortScan.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Port No.", "Port Protocol/Service"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tblPortScan.getTableHeader().setReorderingAllowed(false);
        scrPortScan.setViewportView(tblPortScan);
        if (tblPortScan.getColumnModel().getColumnCount() > 0) {
            tblPortScan.getColumnModel().getColumn(0).setResizable(false);
            tblPortScan.getColumnModel().getColumn(1).setResizable(false);
        }

        btnExportResultsPortScan.setBackground(new java.awt.Color(45, 45, 45));
        btnExportResultsPortScan.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        btnExportResultsPortScan.setForeground(new java.awt.Color(233, 247, 249));
        btnExportResultsPortScan.setText("Export Results");
        btnExportResultsPortScan.setToolTipText("Exports the results to a JSON file.");
        btnExportResultsPortScan.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btnExportResultsPortScan.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExportResultsPortScanActionPerformed(evt);
            }
        });

        lblPortRangeError.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblPortRangeError.setForeground(new java.awt.Color(255, 51, 0));

        lblIPAddressErrorPortScan.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblIPAddressErrorPortScan.setForeground(new java.awt.Color(255, 51, 0));

        lblPortScanInProgress.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblPortScanInProgress.setForeground(new java.awt.Color(0, 204, 0));

        lblTimeoutPortScan.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblTimeoutPortScan.setForeground(new java.awt.Color(233, 247, 249));
        lblTimeoutPortScan.setText("Timeout after (ms):");

        spnTimeoutPortScan.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        spnTimeoutPortScan.setModel(new javax.swing.SpinnerNumberModel(500, 100, 10000, 1));
        spnTimeoutPortScan.setToolTipText("How long the scan waits for a response.");
        spnTimeoutPortScan.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        spnTimeoutPortScan.setPreferredSize(new java.awt.Dimension(104, 23));

        prgPortScan.setBackground(new java.awt.Color(255, 255, 255));
        prgPortScan.setFont(new java.awt.Font("Dubai", 0, 10)); // NOI18N
        prgPortScan.setForeground(new java.awt.Color(0, 204, 0));
        prgPortScan.setName(""); // NOI18N
        prgPortScan.setStringPainted(true);

        javax.swing.GroupLayout pnlPortScanLayout = new javax.swing.GroupLayout(pnlPortScan);
        pnlPortScan.setLayout(pnlPortScanLayout);
        pnlPortScanLayout.setHorizontalGroup(
            pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlPortScanLayout.createSequentialGroup()
                .addComponent(lblPortScan, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlPortScanLayout.createSequentialGroup()
                .addGroup(pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(pnlPortScanLayout.createSequentialGroup()
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(btnExportResultsPortScan, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, pnlPortScanLayout.createSequentialGroup()
                        .addGap(30, 30, 30)
                        .addGroup(pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(prgPortScan, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(pnlPortScanLayout.createSequentialGroup()
                                .addGroup(pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(lblPortRange)
                                    .addComponent(lblIPAdressPortScan)
                                    .addComponent(lblTimeoutPortScan))
                                .addGap(18, 18, 18)
                                .addGroup(pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addGroup(pnlPortScanLayout.createSequentialGroup()
                                        .addComponent(spnBottomRangePort, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(lblDash)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(spnTopRangePort, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addComponent(btnStartPortScan, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(txfIPAddressPortScan)
                                    .addComponent(spnTimeoutPortScan, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addGap(18, 18, 18)
                                .addGroup(pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(lblIPAddressErrorPortScan, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(lblPortRangeError, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(lblPortScanInProgress, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                            .addComponent(scrPortScan, javax.swing.GroupLayout.Alignment.TRAILING))))
                .addGap(30, 30, 30))
        );
        pnlPortScanLayout.setVerticalGroup(
            pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlPortScanLayout.createSequentialGroup()
                .addGap(36, 36, 36)
                .addComponent(lblPortScan, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(txfIPAddressPortScan, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(lblIPAdressPortScan))
                    .addComponent(lblIPAddressErrorPortScan, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(spnBottomRangePort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(spnTopRangePort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(lblDash)
                        .addComponent(lblPortRange))
                    .addComponent(lblPortRangeError, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(19, 19, 19)
                .addGroup(pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblTimeoutPortScan)
                    .addComponent(spnTimeoutPortScan, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(pnlPortScanLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(btnStartPortScan)
                    .addComponent(lblPortScanInProgress, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(30, 30, 30)
                .addComponent(scrPortScan, javax.swing.GroupLayout.PREFERRED_SIZE, 306, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(prgPortScan, javax.swing.GroupLayout.PREFERRED_SIZE, 18, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(30, 30, 30)
                .addComponent(btnExportResultsPortScan)
                .addContainerGap(45, Short.MAX_VALUE))
        );

        pnlMainPanel.add(pnlPortScan, "cardPortScan");

        pnlTCPMessageListen.setBackground(new java.awt.Color(49, 49, 49));

        lblTCPMessageListen.setFont(new java.awt.Font("Dubai Medium", 1, 24)); // NOI18N
        lblTCPMessageListen.setForeground(new java.awt.Color(233, 247, 249));
        lblTCPMessageListen.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblTCPMessageListen.setText("TCP Message - Listen");

        lblPortTCPMessageListen.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblPortTCPMessageListen.setForeground(new java.awt.Color(233, 247, 249));
        lblPortTCPMessageListen.setText("Enter the port to listen on:");

        spnPortTCPMessageListen.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        spnPortTCPMessageListen.setModel(new javax.swing.SpinnerNumberModel(1234, 1, 65535, 1));
        spnPortTCPMessageListen.setToolTipText("The port to open the connection on.");
        spnPortTCPMessageListen.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        spnPortTCPMessageListen.setPreferredSize(new java.awt.Dimension(104, 23));

        btnStartTCPMessageListen.setBackground(new java.awt.Color(45, 45, 45));
        btnStartTCPMessageListen.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        btnStartTCPMessageListen.setForeground(new java.awt.Color(233, 247, 249));
        btnStartTCPMessageListen.setText("Start TCP Listen");
        btnStartTCPMessageListen.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btnStartTCPMessageListen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnStartTCPMessageListenActionPerformed(evt);
            }
        });

        lblTCPMessageListenInProgress.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblTCPMessageListenInProgress.setForeground(new java.awt.Color(0, 204, 0));

        btnExportResultsTCPMessageListen.setBackground(new java.awt.Color(45, 45, 45));
        btnExportResultsTCPMessageListen.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        btnExportResultsTCPMessageListen.setForeground(new java.awt.Color(233, 247, 249));
        btnExportResultsTCPMessageListen.setText("Export Results");
        btnExportResultsTCPMessageListen.setToolTipText("Exports the results to a text file.");
        btnExportResultsTCPMessageListen.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btnExportResultsTCPMessageListen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExportResultsTCPMessageListenActionPerformed(evt);
            }
        });

        btnSendTCPMessageListen.setBackground(new java.awt.Color(45, 45, 45));
        btnSendTCPMessageListen.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        btnSendTCPMessageListen.setForeground(new java.awt.Color(233, 247, 249));
        btnSendTCPMessageListen.setText("Send");
        btnSendTCPMessageListen.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btnSendTCPMessageListen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSendTCPMessageListenActionPerformed(evt);
            }
        });

        lblEnterMessageTCPMessageListen.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblEnterMessageTCPMessageListen.setForeground(new java.awt.Color(233, 247, 249));
        lblEnterMessageTCPMessageListen.setText("Enter message:");

        txpTCPMessageListen.setEditable(false);
        txpTCPMessageListen.setBackground(new java.awt.Color(255, 255, 255));
        txpTCPMessageListen.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        txpTCPMessageListen.setForeground(new java.awt.Color(45, 45, 45));
        txpTCPMessageListen.setToolTipText("Messages will appear here");
        scrTCPMessageListen.setViewportView(txpTCPMessageListen);

        txfMessageTCPMessageListen.setBackground(new java.awt.Color(255, 255, 255));
        txfMessageTCPMessageListen.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        txfMessageTCPMessageListen.setForeground(new java.awt.Color(45, 45, 45));
        txfMessageTCPMessageListen.setToolTipText("Write the message here.");

        javax.swing.GroupLayout pnlTCPMessageListenLayout = new javax.swing.GroupLayout(pnlTCPMessageListen);
        pnlTCPMessageListen.setLayout(pnlTCPMessageListenLayout);
        pnlTCPMessageListenLayout.setHorizontalGroup(
            pnlTCPMessageListenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(lblTCPMessageListen, javax.swing.GroupLayout.DEFAULT_SIZE, 1000, Short.MAX_VALUE)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlTCPMessageListenLayout.createSequentialGroup()
                .addGroup(pnlTCPMessageListenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(pnlTCPMessageListenLayout.createSequentialGroup()
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(btnExportResultsTCPMessageListen, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, pnlTCPMessageListenLayout.createSequentialGroup()
                        .addGap(30, 30, 30)
                        .addGroup(pnlTCPMessageListenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlTCPMessageListenLayout.createSequentialGroup()
                                .addComponent(lblPortTCPMessageListen)
                                .addGap(18, 18, 18)
                                .addGroup(pnlTCPMessageListenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(btnStartTCPMessageListen, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(spnPortTCPMessageListen, javax.swing.GroupLayout.DEFAULT_SIZE, 120, Short.MAX_VALUE))
                                .addGap(18, 18, 18)
                                .addComponent(lblTCPMessageListenInProgress, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlTCPMessageListenLayout.createSequentialGroup()
                                .addComponent(lblEnterMessageTCPMessageListen)
                                .addGap(18, 18, 18)
                                .addComponent(txfMessageTCPMessageListen)
                                .addGap(18, 18, 18)
                                .addComponent(btnSendTCPMessageListen, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(scrTCPMessageListen))))
                .addGap(30, 30, 30))
        );
        pnlTCPMessageListenLayout.setVerticalGroup(
            pnlTCPMessageListenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlTCPMessageListenLayout.createSequentialGroup()
                .addGap(36, 36, 36)
                .addComponent(lblTCPMessageListen)
                .addGap(18, 18, 18)
                .addGroup(pnlTCPMessageListenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblPortTCPMessageListen)
                    .addComponent(spnPortTCPMessageListen, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(pnlTCPMessageListenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(btnStartTCPMessageListen)
                    .addComponent(lblTCPMessageListenInProgress, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(30, 30, 30)
                .addComponent(scrTCPMessageListen, javax.swing.GroupLayout.DEFAULT_SIZE, 384, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addGroup(pnlTCPMessageListenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(btnSendTCPMessageListen, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(lblEnterMessageTCPMessageListen, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(txfMessageTCPMessageListen, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addGap(30, 30, 30)
                .addComponent(btnExportResultsTCPMessageListen)
                .addGap(45, 45, 45))
        );

        pnlMainPanel.add(pnlTCPMessageListen, "cardTCPMessageListen");

        pnlDevicePing.setBackground(new java.awt.Color(49, 49, 49));

        lblDevicePing.setFont(new java.awt.Font("Dubai Medium", 1, 24)); // NOI18N
        lblDevicePing.setForeground(new java.awt.Color(233, 247, 249));
        lblDevicePing.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblDevicePing.setText("Device Ping");

        lblIPAddressDevicePing.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblIPAddressDevicePing.setForeground(new java.awt.Color(233, 247, 249));
        lblIPAddressDevicePing.setText("Enter the IP address:");

        lblPingInterval.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblPingInterval.setForeground(new java.awt.Color(233, 247, 249));
        lblPingInterval.setText("Enter the ping interval (ms):");

        spnPingInterval.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        spnPingInterval.setModel(new javax.swing.SpinnerNumberModel(100, 100, 10000, 1));
        spnPingInterval.setToolTipText("How often to send each ping.");
        spnPingInterval.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        spnPingInterval.setPreferredSize(new java.awt.Dimension(104, 23));

        txfIPAddressDevicePing.setBackground(new java.awt.Color(255, 255, 255));
        txfIPAddressDevicePing.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        txfIPAddressDevicePing.setForeground(new java.awt.Color(45, 45, 45));
        txfIPAddressDevicePing.setText(DEFAULT_IP_ADDRESS_TEXT);
        txfIPAddressDevicePing.setToolTipText("The device to ping.");
        txfIPAddressDevicePing.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 5, 1, 1));
        txfIPAddressDevicePing.setPreferredSize(new java.awt.Dimension(104, 23));
        txfIPAddressDevicePing.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                txfIPAddressDevicePingFocusGained(evt);
            }
        });

        lblContinuousPinging.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblContinuousPinging.setForeground(new java.awt.Color(233, 247, 249));
        lblContinuousPinging.setText("Continuous pinging:");

        chkContinuousPinging.setBackground(new java.awt.Color(49, 49, 49));
        chkContinuousPinging.setForeground(new java.awt.Color(63, 63, 63));
        chkContinuousPinging.setToolTipText("Pings until manually stopped.");
        chkContinuousPinging.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chkContinuousPingingActionPerformed(evt);
            }
        });

        lblNumberOfPings.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblNumberOfPings.setForeground(new java.awt.Color(233, 247, 249));
        lblNumberOfPings.setText("Enter the number of pings:");

        spnNumberOfPings.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        spnNumberOfPings.setModel(new javax.swing.SpinnerNumberModel(10, 1, 100, 1));
        spnNumberOfPings.setToolTipText("How many pings to send.");
        spnNumberOfPings.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        spnNumberOfPings.setPreferredSize(new java.awt.Dimension(104, 23));

        btnStartDevicePing.setBackground(new java.awt.Color(45, 45, 45));
        btnStartDevicePing.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        btnStartDevicePing.setForeground(new java.awt.Color(233, 247, 249));
        btnStartDevicePing.setText("Start Device Ping");
        btnStartDevicePing.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btnStartDevicePing.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnStartDevicePingActionPerformed(evt);
            }
        });

        tblDevicePing.setBackground(new java.awt.Color(255, 255, 255));
        tblDevicePing.setForeground(new java.awt.Color(45, 45, 45));
        tblDevicePing.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "IP Address", "Round Trip Time (ms)", "Reachable", "Packet Loss (%)"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tblDevicePing.getTableHeader().setReorderingAllowed(false);
        scrDevicePing.setViewportView(tblDevicePing);
        if (tblDevicePing.getColumnModel().getColumnCount() > 0) {
            tblDevicePing.getColumnModel().getColumn(0).setResizable(false);
            tblDevicePing.getColumnModel().getColumn(1).setResizable(false);
            tblDevicePing.getColumnModel().getColumn(2).setResizable(false);
        }

        btnExportResultsDevicePing.setBackground(new java.awt.Color(45, 45, 45));
        btnExportResultsDevicePing.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        btnExportResultsDevicePing.setForeground(new java.awt.Color(233, 247, 249));
        btnExportResultsDevicePing.setText("Export Results");
        btnExportResultsDevicePing.setToolTipText("Exports the results to a JSON file.");
        btnExportResultsDevicePing.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btnExportResultsDevicePing.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExportResultsDevicePingActionPerformed(evt);
            }
        });

        lblIPAddressErrorDevicePing.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblIPAddressErrorDevicePing.setForeground(new java.awt.Color(255, 51, 0));

        lblDevicePingInProgress.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblDevicePingInProgress.setForeground(new java.awt.Color(0, 204, 0));

        tblDevicePingPacketResults.setBackground(new java.awt.Color(255, 255, 255));
        tblDevicePingPacketResults.setForeground(new java.awt.Color(45, 45, 45));
        tblDevicePingPacketResults.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Pings Sent", "Successful Pings", "Unsuccessful Pings", "Packet Loss (%)"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tblDevicePingPacketResults.getTableHeader().setReorderingAllowed(false);
        scrDevicePingPacketResults.setViewportView(tblDevicePingPacketResults);
        if (tblDevicePingPacketResults.getColumnModel().getColumnCount() > 0) {
            tblDevicePingPacketResults.getColumnModel().getColumn(0).setResizable(false);
            tblDevicePingPacketResults.getColumnModel().getColumn(1).setResizable(false);
            tblDevicePingPacketResults.getColumnModel().getColumn(2).setResizable(false);
        }

        tblDevicePingResponseResults.setBackground(new java.awt.Color(255, 255, 255));
        tblDevicePingResponseResults.setForeground(new java.awt.Color(45, 45, 45));
        tblDevicePingResponseResults.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Minimum Round Trip Time (ms)", "Maximum Round Trip Time (ms)", "Average Round Trip Time (ms)"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tblDevicePingResponseResults.getTableHeader().setReorderingAllowed(false);
        scrDevicePingResponseResults.setViewportView(tblDevicePingResponseResults);
        if (tblDevicePingResponseResults.getColumnModel().getColumnCount() > 0) {
            tblDevicePingResponseResults.getColumnModel().getColumn(0).setResizable(false);
            tblDevicePingResponseResults.getColumnModel().getColumn(1).setResizable(false);
            tblDevicePingResponseResults.getColumnModel().getColumn(2).setResizable(false);
        }

        javax.swing.GroupLayout pnlDevicePingLayout = new javax.swing.GroupLayout(pnlDevicePing);
        pnlDevicePing.setLayout(pnlDevicePingLayout);
        pnlDevicePingLayout.setHorizontalGroup(
            pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(lblDevicePing, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(pnlDevicePingLayout.createSequentialGroup()
                .addGap(30, 30, 30)
                .addGroup(pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(pnlDevicePingLayout.createSequentialGroup()
                        .addGroup(pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(btnExportResultsDevicePing, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(scrDevicePing, javax.swing.GroupLayout.PREFERRED_SIZE, 940, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(scrDevicePingPacketResults, javax.swing.GroupLayout.PREFERRED_SIZE, 940, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(scrDevicePingResponseResults, javax.swing.GroupLayout.PREFERRED_SIZE, 940, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(30, 30, 30))
                    .addGroup(pnlDevicePingLayout.createSequentialGroup()
                        .addGroup(pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblPingInterval)
                            .addComponent(lblContinuousPinging)
                            .addComponent(lblNumberOfPings)
                            .addComponent(lblIPAddressDevicePing))
                        .addGap(18, 18, 18)
                        .addGroup(pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(txfIPAddressDevicePing, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(spnPingInterval, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(spnNumberOfPings, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlDevicePingLayout.createSequentialGroup()
                                .addGap(0, 0, Short.MAX_VALUE)
                                .addComponent(chkContinuousPinging))
                            .addComponent(btnStartDevicePing, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(18, 18, 18)
                        .addGroup(pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblIPAddressErrorDevicePing, javax.swing.GroupLayout.PREFERRED_SIZE, 609, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblDevicePingInProgress, javax.swing.GroupLayout.PREFERRED_SIZE, 614, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(25, 25, 25))))
        );
        pnlDevicePingLayout.setVerticalGroup(
            pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlDevicePingLayout.createSequentialGroup()
                .addGap(36, 36, 36)
                .addGroup(pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(pnlDevicePingLayout.createSequentialGroup()
                        .addComponent(lblDevicePing)
                        .addGap(18, 18, 18)
                        .addGroup(pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(lblIPAddressDevicePing)
                            .addComponent(txfIPAddressDevicePing, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addComponent(lblIPAddressErrorDevicePing, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblPingInterval)
                    .addComponent(spnPingInterval, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(spnNumberOfPings, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lblNumberOfPings))
                .addGap(18, 18, 18)
                .addGroup(pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(lblContinuousPinging, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(chkContinuousPinging, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addGroup(pnlDevicePingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(lblDevicePingInProgress, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnStartDevicePing, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(30, 30, 30)
                .addComponent(scrDevicePing, javax.swing.GroupLayout.PREFERRED_SIZE, 185, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(scrDevicePingResponseResults, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(scrDevicePingPacketResults, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(30, 30, 30)
                .addComponent(btnExportResultsDevicePing, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(45, Short.MAX_VALUE))
        );

        pnlMainPanel.add(pnlDevicePing, "cardDevicePing");

        pnlTCPMessageConnect.setBackground(new java.awt.Color(49, 49, 49));
        pnlTCPMessageConnect.setPreferredSize(new java.awt.Dimension(1000, 720));

        lblTCPMessageConnect.setFont(new java.awt.Font("Dubai Medium", 1, 24)); // NOI18N
        lblTCPMessageConnect.setForeground(new java.awt.Color(233, 247, 249));
        lblTCPMessageConnect.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblTCPMessageConnect.setText("TCP Message - Connect");

        lblPortTCPMessageConnect.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblPortTCPMessageConnect.setForeground(new java.awt.Color(233, 247, 249));
        lblPortTCPMessageConnect.setText("Enter the port to connect to:");

        lblIPAddressTCPMessageConnect.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblIPAddressTCPMessageConnect.setForeground(new java.awt.Color(233, 247, 249));
        lblIPAddressTCPMessageConnect.setText("Enter the IP address:");

        txfIPAddressTCPMessageConnect.setBackground(new java.awt.Color(255, 255, 255));
        txfIPAddressTCPMessageConnect.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        txfIPAddressTCPMessageConnect.setForeground(new java.awt.Color(45, 45, 45));
        txfIPAddressTCPMessageConnect.setText(DEFAULT_IP_ADDRESS_TEXT);
        txfIPAddressTCPMessageConnect.setToolTipText("The device to connect to.");
        txfIPAddressTCPMessageConnect.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 5, 1, 1));
        txfIPAddressTCPMessageConnect.setPreferredSize(new java.awt.Dimension(104, 23));
        txfIPAddressTCPMessageConnect.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                txfIPAddressTCPMessageConnectFocusGained(evt);
            }
        });

        spnPortTCPMessageConnect.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        spnPortTCPMessageConnect.setModel(new javax.swing.SpinnerNumberModel(1234, 1, 65535, 1));
        spnPortTCPMessageConnect.setToolTipText("The port to connect on.");
        spnPortTCPMessageConnect.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        spnPortTCPMessageConnect.setPreferredSize(new java.awt.Dimension(104, 23));

        btnStartTCPMessageConnect.setBackground(new java.awt.Color(45, 45, 45));
        btnStartTCPMessageConnect.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        btnStartTCPMessageConnect.setForeground(new java.awt.Color(233, 247, 249));
        btnStartTCPMessageConnect.setText("Start TCP Connect");
        btnStartTCPMessageConnect.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btnStartTCPMessageConnect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnStartTCPMessageConnectActionPerformed(evt);
            }
        });

        lblIPAddressErrorTCPMessageConnect.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblIPAddressErrorTCPMessageConnect.setForeground(new java.awt.Color(255, 51, 0));

        lblTCPMessageConnectInProgress.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblTCPMessageConnectInProgress.setForeground(new java.awt.Color(0, 204, 0));

        txpTCPMessageConnect.setEditable(false);
        txpTCPMessageConnect.setBackground(new java.awt.Color(255, 255, 255));
        txpTCPMessageConnect.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        txpTCPMessageConnect.setForeground(new java.awt.Color(45, 45, 45));
        txpTCPMessageConnect.setToolTipText("Messages will appear here");
        scrTCPMessageConnect.setViewportView(txpTCPMessageConnect);

        lblEnterMessageTCPMessageConnect.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        lblEnterMessageTCPMessageConnect.setForeground(new java.awt.Color(233, 247, 249));
        lblEnterMessageTCPMessageConnect.setText("Enter message:");

        txfMessageTCPMessageConnect.setBackground(new java.awt.Color(255, 255, 255));
        txfMessageTCPMessageConnect.setFont(new java.awt.Font("Dubai Medium", 0, 14)); // NOI18N
        txfMessageTCPMessageConnect.setForeground(new java.awt.Color(45, 45, 45));
        txfMessageTCPMessageConnect.setToolTipText("Write the message here.");

        btnSendTCPMessageConnect.setBackground(new java.awt.Color(45, 45, 45));
        btnSendTCPMessageConnect.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        btnSendTCPMessageConnect.setForeground(new java.awt.Color(233, 247, 249));
        btnSendTCPMessageConnect.setText("Send");
        btnSendTCPMessageConnect.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btnSendTCPMessageConnect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSendTCPMessageConnectActionPerformed(evt);
            }
        });

        btnExportResultsTCPMessageConnect.setBackground(new java.awt.Color(45, 45, 45));
        btnExportResultsTCPMessageConnect.setFont(new java.awt.Font("Dubai", 0, 12)); // NOI18N
        btnExportResultsTCPMessageConnect.setForeground(new java.awt.Color(233, 247, 249));
        btnExportResultsTCPMessageConnect.setText("Export Results");
        btnExportResultsTCPMessageConnect.setToolTipText("Exports the results to a text file.");
        btnExportResultsTCPMessageConnect.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btnExportResultsTCPMessageConnect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExportResultsTCPMessageConnectActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout pnlTCPMessageConnectLayout = new javax.swing.GroupLayout(pnlTCPMessageConnect);
        pnlTCPMessageConnect.setLayout(pnlTCPMessageConnectLayout);
        pnlTCPMessageConnectLayout.setHorizontalGroup(
            pnlTCPMessageConnectLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(lblTCPMessageConnect, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlTCPMessageConnectLayout.createSequentialGroup()
                .addGroup(pnlTCPMessageConnectLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(pnlTCPMessageConnectLayout.createSequentialGroup()
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(btnExportResultsTCPMessageConnect, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(pnlTCPMessageConnectLayout.createSequentialGroup()
                        .addGap(30, 30, 30)
                        .addGroup(pnlTCPMessageConnectLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(pnlTCPMessageConnectLayout.createSequentialGroup()
                                .addComponent(lblEnterMessageTCPMessageConnect)
                                .addGap(18, 18, 18)
                                .addComponent(txfMessageTCPMessageConnect)
                                .addGap(18, 18, 18)
                                .addComponent(btnSendTCPMessageConnect, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(scrTCPMessageConnect)
                            .addGroup(pnlTCPMessageConnectLayout.createSequentialGroup()
                                .addGroup(pnlTCPMessageConnectLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(lblIPAddressTCPMessageConnect)
                                    .addComponent(lblPortTCPMessageConnect))
                                .addGap(18, 18, 18)
                                .addGroup(pnlTCPMessageConnectLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(txfIPAddressTCPMessageConnect, javax.swing.GroupLayout.DEFAULT_SIZE, 120, Short.MAX_VALUE)
                                    .addComponent(spnPortTCPMessageConnect, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(btnStartTCPMessageConnect, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addGap(18, 18, 18)
                                .addGroup(pnlTCPMessageConnectLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(lblIPAddressErrorTCPMessageConnect, javax.swing.GroupLayout.DEFAULT_SIZE, 622, Short.MAX_VALUE)
                                    .addComponent(lblTCPMessageConnectInProgress, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))))
                .addGap(30, 30, 30))
        );
        pnlTCPMessageConnectLayout.setVerticalGroup(
            pnlTCPMessageConnectLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlTCPMessageConnectLayout.createSequentialGroup()
                .addGap(36, 36, 36)
                .addComponent(lblTCPMessageConnect)
                .addGap(18, 18, 18)
                .addGroup(pnlTCPMessageConnectLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(pnlTCPMessageConnectLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(lblIPAddressTCPMessageConnect)
                        .addComponent(txfIPAddressTCPMessageConnect, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(lblIPAddressErrorTCPMessageConnect, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addGroup(pnlTCPMessageConnectLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblPortTCPMessageConnect)
                    .addComponent(spnPortTCPMessageConnect, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(pnlTCPMessageConnectLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(lblTCPMessageConnectInProgress, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnStartTCPMessageConnect, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(30, 30, 30)
                .addComponent(scrTCPMessageConnect, javax.swing.GroupLayout.PREFERRED_SIZE, 341, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(pnlTCPMessageConnectLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblEnterMessageTCPMessageConnect)
                    .addComponent(txfMessageTCPMessageConnect, javax.swing.GroupLayout.PREFERRED_SIZE, 26, Short.MAX_VALUE)
                    .addComponent(btnSendTCPMessageConnect, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(30, 30, 30)
                .addComponent(btnExportResultsTCPMessageConnect)
                .addContainerGap(45, Short.MAX_VALUE))
        );

        pnlMainPanel.add(pnlTCPMessageConnect, "cardTCPMessageConnect");

        javax.swing.GroupLayout pnlHomePageLayout = new javax.swing.GroupLayout(pnlHomePage);
        pnlHomePage.setLayout(pnlHomePageLayout);
        pnlHomePageLayout.setHorizontalGroup(
            pnlHomePageLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlHomePageLayout.createSequentialGroup()
                .addComponent(pnlSideBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(pnlMainPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(365, 365, 365))
        );
        pnlHomePageLayout.setVerticalGroup(
            pnlHomePageLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(pnlSideBar, javax.swing.GroupLayout.DEFAULT_SIZE, 726, Short.MAX_VALUE)
            .addGroup(pnlHomePageLayout.createSequentialGroup()
                .addComponent(pnlMainPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(pnlHomePage, javax.swing.GroupLayout.PREFERRED_SIZE, 1280, javax.swing.GroupLayout.PREFERRED_SIZE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(pnlHomePage, javax.swing.GroupLayout.PREFERRED_SIZE, 720, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Called when the user has pressed the button to switch to the subnet scan
     * card.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnSubnetScanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSubnetScanActionPerformed
        // Show the subnet scan card.
        card.show(pnlMainPanel, "cardSubnetScan");
        // Mark the TCP message last flag false.
        tcpMessageLast = false;
    }//GEN-LAST:event_btnSubnetScanActionPerformed

    /**
     * Called when the user has pressed the button to switch to the device ping
     * card.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnDevicePingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDevicePingActionPerformed
        // Show the device ping card.
        card.show(pnlMainPanel, "cardDevicePing");
        // Mark the TCP message last flag false.
        tcpMessageLast = false;
    }//GEN-LAST:event_btnDevicePingActionPerformed

    /**
     * Called when the user has pressed the button to switch to the port scan
     * card.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnPortScanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnPortScanActionPerformed
        // Show the port scan card.
        card.show(pnlMainPanel, "cardPortScan");
        // Mark the TCP message last flag false.
        tcpMessageLast = false;
    }//GEN-LAST:event_btnPortScanActionPerformed

    /**
     * Called when the user has pressed the general button to switch to the
     * either the last used TCP Message function card or the listen function if
     * it is the first time accessing it.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnTCPMessageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnTCPMessageActionPerformed
        /**
         * If the TCP message listen card is currently being shown, cycle to the
         * TCP message connect card.
         */
        if (tcpMessageLast && listenLast) {
            // Show the TCP message connect card.
            card.show(pnlMainPanel, "cardTCPMessageConnect");
            // Mark the TCP message listen last flag false.
            listenLast = false;

            /**
             * If the TCP message connect card is currently being shown, cycle
             * to the TCP message listen card.
             */
        } else if (tcpMessageLast && !listenLast) {
            // Show the TCP message listen card.
            card.show(pnlMainPanel, "cardTCPMessageListen");
            // Mark the TCP message listen last flag true.
            listenLast = true;

            /**
             * If the TCP message card is not being shown, but the last TCP
             * message card shown was a TCP message listen card, cycle to the
             * TCP message listen card.
             */
        } else if (!tcpMessageLast && listenLast) {
            // Show the TCP message listen last card.
            card.show(pnlMainPanel, "cardTCPMessageListen");
            // Mark the TCP message listen last flag true.
            listenLast = true;

            /**
             * If the TCP message card is not being shown, but the last TCP
             * message card shown was a TCP message connect card, cycle to the
             * TCP message connect card.
             */
        } else if (!tcpMessageLast && !listenLast) {
            // Show the TCP message connect card.
            card.show(pnlMainPanel, "cardTCPMessageConnect");
            // Mark the TCP message listen last flag false.
            listenLast = false;
        }

        // Mark the TCP message last flag true.
        tcpMessageLast = true;
    }//GEN-LAST:event_btnTCPMessageActionPerformed

    /**
     * Called when the user has pressed the button to switch to import results.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnImportResultsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnImportResultsActionPerformed
        // Create a new ImportResutls object.
        ImportResults importResults = new ImportResults(pnlHomePage, this);

        // Prompt the used to select a file to import the results from.
        importResults.setImportResultsPath();

        try {
            // Determine if the scan is a PingPal scan, and if so import the results.
            importResults.determineScanType();
        } catch (InvalidScanTypeException ex) {
            // Display an error message if the contents of the file are not that of a PingPal scan.
            JOptionPane.showMessageDialog(pnlHomePage, "This file does not contain the results of a PingPal scan.", "Results File Error", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_btnImportResultsActionPerformed

    /**
     * Called when the user has ticked the checkbox to select continuous pinging
     * during a device ping.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void chkContinuousPingingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chkContinuousPingingActionPerformed
        // If the checkbox is selected.
        if (chkContinuousPinging.isSelected()) {
            // Gray out the spinner used to select the number of pings to indicate that this field no longer applies.
            lblNumberOfPings.setForeground(ValidationUtils.GRAYED_OUT_COLOR);
            // Disable the user from being able to change the value of the spinner.
            spnNumberOfPings.setEnabled(false);

            // If the check box is unselected.
        } else {
            // Return the spinner to default colour.
            lblNumberOfPings.setForeground(ValidationUtils.NORMAL_TEXT_COLOR);
            // Enable the user to be able to change the value of the spinner.
            spnNumberOfPings.setEnabled(true);
        }
    }//GEN-LAST:event_chkContinuousPingingActionPerformed

    /**
     * Called when the user has pressed the button to export the results of a
     * device ping.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnExportResultsDevicePingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExportResultsDevicePingActionPerformed
        /**
         * If the device ping thread is not null and if it is alive, and if a
         * set of results exists.
         */
        if (devicePingThread != null && devicePingThread.isAlive() && devicePing != null) {
            // Signal the ping logic to stop.
            devicePing.requestStop();
            /// Interrupt the thread to break out of blocking calls.
            devicePingThread.interrupt();
        }

        // Create a new ExportResults object and export the device ping results.
        ExportResults exportResults = new ExportResults(pnlDevicePing);
        exportResults.exportResults(devicePing);
    }//GEN-LAST:event_btnExportResultsDevicePingActionPerformed

    /**
     * Handles the Start/Stop Port Scan button click.
     * <p>
     * When no scan is running, validates inputs, updates UI, and launches a
     * background thread to perform the port scan. If a scan is already running,
     * requests it to stop.
     * </p>
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnStartPortScanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnStartPortScanActionPerformed
        // If no port scan is currently in progress.
        if (!portScanInProgress) {
            // Clear previous IP address error markers.
            txfIPAddressPortScan.setBackground(Color.WHITE);
            lblIPAddressErrorPortScan.setText("");

            // Clear previous port range error markers.
            spnBottomRangePort.setBackground(Color.WHITE);
            spnTopRangePort.setBackground(Color.WHITE);
            lblPortRangeError.setText("");

            // Flag to track overall input validity.
            boolean valid = true;

            // Validate IP address presence and format.
            try {
                // Check that the IP text is not blank.
                ValidationUtils.validateFieldPresence(txfIPAddressPortScan.getText());
                // Check that the IP text matches the expected pattern.
                ValidationUtils.validateIPAddress(txfIPAddressPortScan.getText());

            } catch (BlankFieldException e) {
                // Mark the IP field as erroneous due to lack of presence.
                txfIPAddressPortScan.setBackground(ValidationUtils.ERROR_COLOR);
                lblIPAddressErrorPortScan.setText("Please enter an IP Address.");
                // Set flag to indicate invalidity.
                valid = false;

            } catch (InvalidIPAddressException e) {
                // Mark the IP field as format-invalid.
                txfIPAddressPortScan.setBackground(ValidationUtils.ERROR_COLOR);
                lblIPAddressErrorPortScan.setText("Please enter an IP Address in the correct format (e.g. 192.168.0.1).");
                // Set flag to indicate invalidity.
                valid = false;
            }

            // Validate port range.
            try {
                // Ensure bottom <= top.
                ValidationUtils.validatePortRange((int) spnBottomRangePort.getModel().getValue(), (int) spnTopRangePort.getModel().getValue());

            } catch (InvalidPortRangeException e) {
                // Mark both spinners as erroneous.
                spnBottomRangePort.setBackground(ValidationUtils.ERROR_COLOR);
                spnTopRangePort.setBackground(ValidationUtils.ERROR_COLOR);
                lblPortRangeError.setText("Start value can't be larger than end value. Please enter a valid range.");
                // Set flag to indicate invalidity.
                valid = false;
            }

            // If any validation failed, don't proceed.
            if (!valid) {
                return;
            }

            // If all checks successful, update UI to show port scan has started.
            portScanInProgress = true;

            // Update status label to show activity.
            lblPortScanInProgress.setForeground(ValidationUtils.SUCCESSFUL_SCAN_COLOR);
            lblPortScanInProgress.setText("Running port scan.");

            // Change button text to allow stopping.
            btnStartPortScan.setText("End Port Scan");

            // Retrieve userentered parameters (IP Address, Port Range, and Timeout values).
            String ipAddress = txfIPAddressPortScan.getText();
            int bottomRangePort = (int) spnBottomRangePort.getModel().getValue();
            int topRangePort = (int) spnTopRangePort.getModel().getValue();
            int timeout = (int) spnTimeoutPortScan.getModel().getValue();

            // Instantiate the Port Scan logic with the UI table and progress bar.
            portScan = new PortScan(ipAddress, bottomRangePort, topRangePort, timeout, tblPortScan, prgPortScan);

            // Create and start a new thread to run the scan asynchronously.
            portScanThread = new Thread(() -> {
                // Begin scanning.
                portScan.start();

                // Once done, reset the button label on the EDT.
                invokeLater(() -> btnStartPortScan.setText("Start Port Scan"));

                // Depending on whether the user requested the stop, update the status label.
                if (portScan.isStopRequested()) {
                    // If the used requested the stop update the UI components on the EDT to indicate such.
                    invokeLater(() -> {
                        lblPortScanInProgress.setForeground(ValidationUtils.INTERRUPTED_SCAN_COLOR);
                        lblPortScanInProgress.setText("Port scan interrupted.");
                    });
                } else {
                    // If the used did not request the stop update the UI components on the EDT to indicate such.
                    invokeLater(() -> {
                        lblPortScanInProgress.setForeground(ValidationUtils.SUCCESSFUL_SCAN_COLOR);
                        lblPortScanInProgress.setText("Port scan complete.");
                    });
                }

                // Mark that the scan is no longer in progress.
                portScanInProgress = false;
            });

            // Start the thread.
            portScanThread.start();

            // If the button is pressed and a port scan is running, end the current port scan.
        } else if (portScanThread != null && portScanThread.isAlive() && portScan != null) {
            // Signal the scan logic to stop.
            portScan.requestStop();
            // Forcefully shutdown any remaining executor tasks.
            portScan.shutDownExecutorService();
            // Interrupt the thread to break out of blocking calls.
            portScanThread.interrupt();
        }
    }//GEN-LAST:event_btnStartPortScanActionPerformed

    /**
     * Called when the user has pressed the button to export the results of a
     * port scan.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnExportResultsPortScanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExportResultsPortScanActionPerformed
        /**
         * If the port scan thread is not null and if it is alive, and if a set
         * of results exists.
         */
        if (portScanThread != null && portScanThread.isAlive() && portScan != null) {
            // Signal the scan logic to stop.
            portScan.requestStop();
            // Forcefully shutdown any remaining executor tasks.
            portScan.shutDownExecutorService();
            // Interrupt the thread to break out of blocking calls.
            portScanThread.interrupt();
        }

        // Create a new ExportResults object and export the port scan results.
        ExportResults exportResults = new ExportResults(pnlPortScan);
        exportResults.exportResults(portScan);
    }//GEN-LAST:event_btnExportResultsPortScanActionPerformed

    /**
     * Handles the Start/Stop Subnet Scan button click.
     * <p>
     * When no scan is running, validates the networkrange input, updates the
     * UI, and launches a background thread to perform the subnet scan. If a
     * scan is already running, requests it to stop.
     * </p>
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnStartSubnetScanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnStartSubnetScanActionPerformed
        // If no subnet scan is currently in progress.
        if (!subnetScanInProgress) {
            // Clear previous network range error markers.
            txfNetworkRange.setBackground(Color.WHITE);
            lblNetworkRangeError.setText("");

            // Flag to track overall input validity.
            boolean valid = true;

            // Validate network range presence and format.
            try {
                // Ensure the text field is not blank or null.
                ValidationUtils.validateFieldPresence(txfNetworkRange.getText());
                // Ensure the text matches the CIDR pattern (e.g., "192.168.0.0/24").
                ValidationUtils.validateNetworkRange(txfNetworkRange.getText());

            } catch (BlankFieldException ee) {
                // Mark the network range as erroneous due to lack of presence.
                txfNetworkRange.setBackground(ValidationUtils.ERROR_COLOR);
                lblNetworkRangeError.setText("Please enter a network range.");
                // Set flag to indicate invalidity.
                valid = false;

            } catch (InvalidNetworkRangeException e) {
                // Mark the network range as format-invalid.
                txfNetworkRange.setBackground(ValidationUtils.ERROR_COLOR);
                lblNetworkRangeError.setText("Please enter a network range in the correct format (e.g. 192.168.0.0/24).");
                // Set flag to indicate invalidity.
                valid = false;
            }

            // If any validation failed, don't proceed.
            if (!valid) {
                return;
            }

            // If all checks successful, update UI to show subnet scan has started.
            subnetScanInProgress = true;

            // Update status label to show activity.
            lblSubnetScanInProgress.setForeground(ValidationUtils.SUCCESSFUL_SCAN_COLOR);
            lblSubnetScanInProgress.setText("Running subnet scan.");

            // Change button text to allow stopping.
            btnStartSubnetScan.setText("End Subnet Scan");

            // Retrieve userentered parameters (Network Range and Timeout values).
            String networkRange = txfNetworkRange.getText();
            int timeout = (int) spnTimeoutSubnetScan.getModel().getValue();

            // Instantiate the Subnet Scan logic with the UI table and progress bar.
            subnetScan = new SubnetScan(networkRange, timeout, tblSubnetScan, prgSubnetScan);

            // Create and start a new thread to run the scan asynchronously.
            subnetScanThread = new Thread(() -> {
                // Begin scanning.
                subnetScan.start();

                // Once done, reset the button label on the EDT.
                invokeLater(() -> btnStartSubnetScan.setText("Start Subnet Scan"));

                // Depending on whether the user requested the stop, update the status label.
                if (subnetScan.isStopRequested()) {
                    invokeLater(() -> {
                        // If the used requested the stop update the UI components on the EDT to indicate such.
                        lblSubnetScanInProgress.setForeground(ValidationUtils.INTERRUPTED_SCAN_COLOR);
                        lblSubnetScanInProgress.setText("Subnet scan interrupted.");
                    });
                } else {
                    invokeLater(() -> {
                        // If the used did not request the stop update the UI components on the EDT to indicate such.
                        lblSubnetScanInProgress.setForeground(ValidationUtils.SUCCESSFUL_SCAN_COLOR);
                        lblSubnetScanInProgress.setText("Subnet scan complete.");
                    });
                }

                // Mark that the scan is no longer in progress.
                subnetScanInProgress = false;
            });

            // Start the thread.
            subnetScanThread.start();

            // If the button is pressed and a subnet scan is running, end the current subnet scan.
        } else if (subnetScanThread != null && subnetScanThread.isAlive() && subnetScan != null) {
            // Signal the scan logic to stop.
            subnetScan.requestStop();
            // Forcefully shutdown any remaining executor tasks.
            subnetScan.shutDownExecutorService();
            // Interrupt the thread to break out of blocking calls.
            subnetScanThread.interrupt();
        }
    }//GEN-LAST:event_btnStartSubnetScanActionPerformed

    /**
     * Handles the Start/Stop Device Ping button click.
     * <p>
     * When no ping is running, validates the IP address input, updates the UI,
     * and launches a background thread to perform the device ping. If a ping is
     * already running, requests it to stop.
     * </p>
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnStartDevicePingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnStartDevicePingActionPerformed
        // If no subnet scan is currently in progress.
        if (!devicePingInProgress) {
            // Clear previous IP address error markers.
            txfIPAddressDevicePing.setBackground(Color.WHITE);
            lblIPAddressErrorDevicePing.setText("");

            // Flag to track overall input validity.
            boolean valid = true;

            // Validate IP address presence and format.
            try {
                // Ensure the IP text is not blank or null.
                ValidationUtils.validateFieldPresence(txfIPAddressDevicePing.getText());
                // Check that the IP text matches the expected pattern.
                ValidationUtils.validateIPAddress(txfIPAddressDevicePing.getText());

            } catch (BlankFieldException e) {
                // Mark the IP address as erroneous due to lack of presence.
                txfIPAddressDevicePing.setBackground(ValidationUtils.ERROR_COLOR);
                lblIPAddressErrorDevicePing.setText("Please enter an IP Address.");
                // Set flag to indicate invalidity.
                valid = false;
            } catch (InvalidIPAddressException e) {
                // Mark the IP address as format-invalid.
                txfIPAddressDevicePing.setBackground(ValidationUtils.ERROR_COLOR);
                lblIPAddressErrorDevicePing.setText("Please enter an IP Address in the correct format (e.g. 192.168.0.1).");
                // Set flag to indicate invalidity.
                valid = false;
            }

            // If any validation failed, don't proceed.
            if (!valid) {
                return;
            }

            // If all checks successful, update UI to show device ping has started.
            devicePingInProgress = true;

            // Update status label to show activity.
            lblDevicePingInProgress.setForeground(ValidationUtils.SUCCESSFUL_SCAN_COLOR);
            lblDevicePingInProgress.setText("Running device ping.");

            // Change button text to allow stopping.
            btnStartDevicePing.setText("End Device Ping");

            // Retrieve userentered parameters (IP address, ping interval, numer of pings, and continuous pinging values).
            String ipAddress = txfIPAddressDevicePing.getText();
            int pingInterval = Integer.parseInt("" + spnPingInterval.getModel().getValue());
            int numOfPings = Integer.parseInt("" + spnNumberOfPings.getModel().getValue());
            boolean continuousPinging = chkContinuousPinging.isSelected();

            // Instantiate the Device Ping logic with the UI tables.
            devicePing = new DevicePing(ipAddress, pingInterval, numOfPings, continuousPinging, tblDevicePing, tblDevicePingResponseResults, tblDevicePingPacketResults);

            // Create and start a new thread to run the scan asynchronously.
            devicePingThread = new Thread(() -> {
                // Begin pinging.
                devicePing.start();

                // Once done, reset the button label on the EDT.
                invokeLater(() -> btnStartDevicePing.setText("Start Device Ping"));

                if (devicePing.isStopRequested()) {
                    // If the used requested the stop update the UI components on the EDT to indicate such.
                    invokeLater(() -> {
                        lblDevicePingInProgress.setForeground(ValidationUtils.INTERRUPTED_SCAN_COLOR);
                        lblDevicePingInProgress.setText("Device Ping interrupted.");
                    });
                } else {
                    // If the used did not request the stop update the UI components on the EDT to indicate such.
                    invokeLater(() -> {
                        lblDevicePingInProgress.setForeground(ValidationUtils.SUCCESSFUL_SCAN_COLOR);
                        lblDevicePingInProgress.setText("Device Ping complete.");
                    });
                }

                // Mark that the ping is no longer in progress.
                devicePingInProgress = false;
            });

            // Start the thread.
            devicePingThread.start();

            // If the button is pressed and a device ping is running, end the current device ping
        } else if (devicePingThread != null & devicePingThread.isAlive() && devicePing != null) {
            // Signal the scan logic to stop.
            devicePing.requestStop();
            // Interrupt the thread to break out of blocking calls.
            devicePingThread.interrupt();
        }
    }//GEN-LAST:event_btnStartDevicePingActionPerformed

    /**
     * Called when the user has selected the network range text field.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void txfNetworkRangeFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_txfNetworkRangeFocusGained
        // Clear any text that is in the text box if the default text is being displayed.
        if (txfNetworkRange.getText().equals(DEFAULT_NETWORK_RANGE_TEXT)) {
            txfNetworkRange.setText("");
        }
    }//GEN-LAST:event_txfNetworkRangeFocusGained

    /**
     * Called when the user has selected the device ping IP address text field.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void txfIPAddressDevicePingFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_txfIPAddressDevicePingFocusGained
        // Clear any text that is in the text box if the default text is being displayed.
        if (txfIPAddressDevicePing.getText().equals(DEFAULT_IP_ADDRESS_TEXT)) {
            txfIPAddressDevicePing.setText("");
        }
    }//GEN-LAST:event_txfIPAddressDevicePingFocusGained

    /**
     * Called when the user has selected the port scan IP address text field.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void txfIPAddressPortScanFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_txfIPAddressPortScanFocusGained
        // Clear any text that is in the text box if the default text is being displayed.
        if (txfIPAddressPortScan.getText().equals(DEFAULT_IP_ADDRESS_TEXT)) {
            txfIPAddressPortScan.setText("");
        }
    }//GEN-LAST:event_txfIPAddressPortScanFocusGained

    /**
     * Called when the user has pressed the button to export the results of a
     * subnet scan.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnExportResultsSubnetScanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExportResultsSubnetScanActionPerformed
        /**
         * If the subnet scan thread is not null and if it is alive, and if a
         * set of results exists.
         */
        if (subnetScanThread != null && subnetScanThread.isAlive() && subnetScan != null) {
            // Signal the scan logic to stop.
            subnetScan.requestStop();
            // Forcefully shutdown any remaining executor tasks.
            subnetScan.shutDownExecutorService();
            // Interrupt the thread to break out of blocking calls.
            subnetScanThread.interrupt();
        }

        // Create a new ExportResults object and export the subnet scan results.
        ExportResults exportResults = new ExportResults(pnlSubnetScan);
        exportResults.exportResults(subnetScan);
    }//GEN-LAST:event_btnExportResultsSubnetScanActionPerformed

    /**
     * Called when the user has pressed the button to switch to the TCP message
     * listen card.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnTCPMessageListenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnTCPMessageListenActionPerformed
        // Show the TCP message listen card.
        card.show(pnlMainPanel, "cardTCPMessageListen");
        // Mark the TCP message listen last flag true.
        listenLast = true;
        // Mark the TCP message last flag true.
        tcpMessageLast = true;
    }//GEN-LAST:event_btnTCPMessageListenActionPerformed

    /**
     * Called when the user has pressed the button to switch to the TCP message
     * connect card.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnTCPMessageConnectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnTCPMessageConnectActionPerformed
        // Show the TCP message connect card.
        card.show(pnlMainPanel, "cardTCPMessageConnect");
        // Mark the TCP message listen last flag false.
        listenLast = false;
        // Mark the TCP message last flag false.
        tcpMessageLast = true;
    }//GEN-LAST:event_btnTCPMessageConnectActionPerformed

    /**
     * Handles the action triggered when the "Start TCP Listen" button is
     * clicked.
     * <p>
     * Starts or stops a TCP message connect based on the current state. If no
     * connection is active, this method validates the input, updates the UI,
     * creates a new TCPMessageListen object, and starts a new thread to handle
     * the connection. If a connection is already active, it stops the running
     * connection.
     * </p>
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnStartTCPMessageListenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnStartTCPMessageListenActionPerformed
        // Clear previous network range error markers.
        if (!tcpMessageListenInProgress) {
            // Get the entered port value.
            int port = (int) spnPortTCPMessageListen.getValue();

            // Update UI to show TCP message listen has started.
            tcpMessageListenInProgress = true;

            // Update status label to show activity.
            lblTCPMessageListenInProgress.setForeground(ValidationUtils.SUCCESSFUL_SCAN_COLOR);
            lblTCPMessageListenInProgress.setText("Running TCP message listen.");

            // Change button text to allow stopping.
            btnStartTCPMessageListen.setText("End TCP Listen");

            // Create a new TCPMessageListen instance using the provided port.
            tcpMessageListen = new TCPMessageListen(port, txpTCPMessageListen);

            // Create a new thread to handle the TCP connection listnening in the background.
            tcpMessageListenThread = new Thread(() -> {
                // Begin trying to establish a connection.
                tcpMessageListen.start();

                // Once the connection finishes, update the UI back on the Swing thread to show TCP message listen has stopped.
                invokeLater(() -> {
                    btnStartTCPMessageListen.setText("Start TCP Listen");
                    lblTCPMessageListenInProgress.setForeground(ValidationUtils.SUCCESSFUL_SCAN_COLOR);
                    lblTCPMessageListenInProgress.setText("TCP message listen stopped.");
                });

                // Mark the TCP message connect as no longer running.
                tcpMessageListenInProgress = false;
            });

            // Start the thread.
            tcpMessageListenThread.start();

            // If the button is pressed and a TCP message listen is running, end the current TCP message listen.
        } else if (tcpMessageListenThread != null && tcpMessageListenThread.isAlive() && tcpMessageListen != null) {
            tcpMessageListen.requestStop();
            tcpMessageListenInProgress = false;
        }
    }//GEN-LAST:event_btnStartTCPMessageListenActionPerformed

    /**
     * Handles the "Export Results" button click on the TCP Message Listen
     * panel.
     * <p>
     * If a live TCP connection thread is active, stops it; then prompts the
     * user for a directory and filename, and writes the current text-paned
     * contents to a file via the ExportResults utility.
     * </p>
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnExportResultsTCPMessageListenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExportResultsTCPMessageListenActionPerformed
        // If the TCP connection thread exists and is currently running...
        if (tcpMessageListenThread != null && tcpMessageListenThread.isAlive() && tcpMessageListen != null) {
            // Request the TCP connect logic to stop receiving/sending.
            tcpMessageListen.requestStop();
            // Interrupt the thread to break out of any blocking operations.
            tcpMessageListenThread.interrupt();
        }

        // Create an ExportResults helper, using the listen panel as the parent component. 
        ExportResults exportResults = new ExportResults(pnlTCPMessageListen);
        // Delegate to the helper to export the contents of the TCPMessageListen text pane.
        exportResults.exportResults(tcpMessageListen);
    }//GEN-LAST:event_btnExportResultsTCPMessageListenActionPerformed

    /**
     * Handles the "Send" button click on the TCP Message Listen panel.
     * <p>
     * Sends the text from the input field over the active TCP connection, then
     * clears the input field. Only sends if the connection thread is alive and
     * the socket is currently connected.
     * </p>
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnSendTCPMessageListenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSendTCPMessageListenActionPerformed
        // Check if the TCP connection thread exists, is running, and the socket is connected.
        if (tcpMessageListenThread != null && tcpMessageListenThread.isAlive() && tcpMessageListen != null && tcpMessageListen.deviceConnected()) {
            // Retrieve the message text from the input field and send it.
            tcpMessageListen.sendMessage(txfMessageTCPMessageListen.getText());
            // Clear the input field for the next message.
            txfMessageTCPMessageListen.setText("");
        }
    }//GEN-LAST:event_btnSendTCPMessageListenActionPerformed

    /**
     * Handles the action triggered when the "Start TCP Connect" button is
     * clicked.
     * <p>
     * Starts or stops a TCP message connection based on the current state. If
     * no connection is active, this method validates the input, updates the UI,
     * creates a new TCPMessageConnect object, and starts a new thread to handle
     * the connection. If a connection is already active, it stops the running
     * connection.
     * </p>
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnStartTCPMessageConnectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnStartTCPMessageConnectActionPerformed
        // Clear previous network range error markers.
        if (!tcpMessageConnectInProgress) {
            // Clear previous IP address error markers.
            txfIPAddressTCPMessageConnect.setBackground(Color.WHITE);
            lblIPAddressErrorTCPMessageConnect.setText("");

            // Flag to track overall input validity.
            boolean valid = true;

            // Validate IP address presence and format.
            try {
                // Check that the IP text is not blank.
                ValidationUtils.validateFieldPresence(txfIPAddressTCPMessageConnect.getText());
                // Check that the IP text matches the expected pattern. 
                ValidationUtils.validateIPAddress(txfIPAddressTCPMessageConnect.getText());

            } catch (BlankFieldException e) {
                // Mark the IP field as erroneous due to lack of presence.
                txfIPAddressTCPMessageConnect.setBackground(ValidationUtils.ERROR_COLOR);
                lblIPAddressErrorTCPMessageConnect.setText("Please enter an IP Address.");
                // Set flag to indicate invalidity.
                valid = false;
            } catch (InvalidIPAddressException e) {
                // Mark the IP field as format-invalid.
                txfIPAddressTCPMessageConnect.setBackground(ValidationUtils.ERROR_COLOR);
                lblIPAddressErrorTCPMessageConnect.setText("Please enter an IP Address in the correct format (e.g. 192.168.0.1).");
                // Set flag to indicate invalidity.
                valid = false;
            }

            // If any validation failed, don't proceed.
            if (!valid) {
                return;
            }

            // If all checks successful, update UI to show TCP message connect has started.
            tcpMessageConnectInProgress = true;

            // Update status label to show activity.
            lblTCPMessageConnectInProgress.setForeground(ValidationUtils.SUCCESSFUL_SCAN_COLOR);
            lblTCPMessageConnectInProgress.setText("Running TCP message connect.");

            // Change button text to allow stopping.
            btnStartTCPMessageConnect.setText("End TCP Connect");

            // Create a new TCPMessageConnect instance using the provided IP and port.
            tcpMessageConnect = new TCPMessageConnect(txfIPAddressTCPMessageConnect.getText(), (int) spnPortTCPMessageConnect.getValue(), txpTCPMessageConnect);

            // Create a new thread to handle the TCP connection in the background.
            tcpMessageConnectThread = new Thread(() -> {
                // Begin trying to establish a connection.
                tcpMessageConnect.start();

                // Once the connection finishes, update the UI back on the Swing thread to show TCP message connect has stopped.
                invokeLater(() -> {
                    btnStartTCPMessageConnect.setText("Start TCP Connect");
                    lblTCPMessageConnectInProgress.setForeground(ValidationUtils.SUCCESSFUL_SCAN_COLOR);
                    lblTCPMessageConnectInProgress.setText("TCP message connect stopped.");
                });

                // Mark the TCP message connect as no longer running.
                tcpMessageConnectInProgress = false;
            });

            // Start the thread.
            tcpMessageConnectThread.start();

            // If the button is pressed and a TCP message listen is running, end the current TCP message listen.
        } else if (tcpMessageConnectThread != null && tcpMessageConnectThread.isAlive() && tcpMessageConnect != null) {
            tcpMessageConnect.requestStop();
            tcpMessageConnectInProgress = false;
        }
    }//GEN-LAST:event_btnStartTCPMessageConnectActionPerformed

    /**
     * Called when the user has selected the TCP message connect IP address text
     * field.
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void txfIPAddressTCPMessageConnectFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_txfIPAddressTCPMessageConnectFocusGained
        // Clear any text that is in the text box if the default text is being displayed.
        if (txfIPAddressTCPMessageConnect.getText().equals(DEFAULT_IP_ADDRESS_TEXT)) {
            txfIPAddressTCPMessageConnect.setText("");
        }
    }//GEN-LAST:event_txfIPAddressTCPMessageConnectFocusGained

    /**
     * Handles the "Send" button click on the TCP Message Connect panel.
     * <p>
     * Sends the text from the input field over the active TCP connection, then
     * clears the input field. Only sends if the connection thread is alive and
     * the socket is currently connected.
     * </p>
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnSendTCPMessageConnectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSendTCPMessageConnectActionPerformed
        // Check if the TCP connection thread exists, is running, and the socket is connected.
        if (tcpMessageConnectThread != null && tcpMessageConnectThread.isAlive() && tcpMessageConnect != null && tcpMessageConnect.deviceConnected()) {
            // Retrieve the message text from the input field and send it.
            tcpMessageConnect.sendMessage(txfMessageTCPMessageConnect.getText());
            // Clear the input field for the next message.
            txfMessageTCPMessageConnect.setText("");
        }
    }//GEN-LAST:event_btnSendTCPMessageConnectActionPerformed

    /**
     * Handles the "Export Results" button click on the TCP Message Connect
     * panel.
     * <p>
     * If a live TCP connection thread is active, stops it; then prompts the
     * user for a directory and filename, and writes the current text-paned
     * contents to a file via the ExportResults utility.
     * </p>
     *
     * @param evt the variable containing all of information regarding the
     * button press
     */
    private void btnExportResultsTCPMessageConnectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExportResultsTCPMessageConnectActionPerformed
        // If the TCP connection thread exists and is currently running...
        if (tcpMessageConnectThread != null && tcpMessageConnectThread.isAlive() && tcpMessageConnect != null) {
            // Request the TCP connect logic to stop receiving/sending.
            tcpMessageConnect.requestStop();
            // Interrupt the thread to break out of any blocking operations.
            tcpMessageConnectThread.interrupt();
        }

        // Create an ExportResults helper, using the connect panel as the parent component. 
        ExportResults exportResults = new ExportResults(pnlTCPMessageConnect);
        // Delegate to the helper to export the contents of the TCPMessageConnect text pane.
        exportResults.exportResults(tcpMessageConnect);
    }//GEN-LAST:event_btnExportResultsTCPMessageConnectActionPerformed

    /**
     * Callback invoked when subnet scan results have been imported from a file.
     * <p>
     * This method stops any ongoing scan, displays the Subnet Scan panel,
     * populates the UI controls with imported parameters, loads the results
     * into the table, and resets the UI to reflect a completed import state.
     * </p>
     *
     * @param networkRange the CIDR network range used in the imported scan
     * @param timeout the timeout value (ms) used in the imported scan
     * @param subnetScanResults the list of imported SubnetScanResult objects
     */
    @Override
    public void onSubnetScanResultsImported(String networkRange, int timeout, ArrayList<SubnetScanResult> subnetScanResults) {
        // If a subnet scan is currently running, request it to stop immediately.
        if (subnetScanThread != null && subnetScanThread.isAlive() && subnetScan != null) {
            subnetScan.requestStop();
            subnetScan.shutDownExecutorService();
            subnetScanThread.interrupt();
        }

        // Show the subnet scan card.
        card.show(pnlMainPanel, "cardSubnetScan");
        // Remember that TCP messaging was not last used.
        tcpMessageLast = false;

        // Clear previous network range error markers.
        txfNetworkRange.setBackground(Color.WHITE);
        lblNetworkRangeError.setText("");

        // Set imported network range.
        txfNetworkRange.setText(networkRange);

        // Set imported timeout.
        spnTimeoutSubnetScan.getModel().setValue(timeout);

        // Clear the table.
        DefaultTableModel model = (DefaultTableModel) tblSubnetScan.getModel();

        model.setRowCount(0);

        // Import the results from the file into the table.
        for (SubnetScanResult subnetScanResult : subnetScanResults) {
            model.addRow(new Object[]{subnetScanResult.getIPAddress()});
        }

        // Update the subnet scan object.
        subnetScan = new SubnetScan(networkRange, timeout, tblSubnetScan, prgSubnetScan);
        // Load the imported results into the new object.
        subnetScan.setSubnetScanResults(subnetScanResults);

        // Reset button text.
        btnStartSubnetScan.setText("Start Subnet Scan");
        // Set status message.
        lblSubnetScanInProgress.setText("Results imported successfully.");

        // Update progress bar.
        prgSubnetScan.setValue(100);
    }

    /**
     * Callback invoked when device ping results have been imported from a file.
     * <p>
     * This method stops any ongoing scan, displays the Device Ping panel,
     * populates the UI controls with imported parameters, loads the results
     * into the table, and resets the UI to reflect a completed import state.
     * </p>
     *
     * @param ipAddress the target IP address used in the imported scan
     * @param pingInterval the time interval between each ping in the imported
     * scan
     * @param numOfPings the number of times a device is pinged in the imported
     * scan
     * @param continuousPinging flag to determine whether a device was pinged
     * continuously in the imported scan
     * @param devicePingResults the list of imported devicePingResult objects
     */
    @Override
    public void onDevicePingResultsImported(String ipAddress, int pingInterval, int numOfPings, boolean continuousPinging, ArrayList<DevicePingResult> devicePingResults) {
        // If a device ping is currently running, request it to stop immediately.
        if (devicePingThread != null && devicePingThread.isAlive() && devicePing != null) {
            devicePing.requestStop();
            devicePingThread.interrupt();
        }

        // Show the device ping card.
        card.show(pnlMainPanel, "cardDevicePing");
        // Remember that TCP messaging was not last used.
        tcpMessageLast = false;

        // Clear previous IP address error markers.
        txfIPAddressDevicePing.setBackground(Color.WHITE);
        lblIPAddressErrorDevicePing.setText("");
        // Set imported IP address.
        txfIPAddressDevicePing.setText(ipAddress);

        // Set imported ping interval.
        spnPingInterval.setValue(pingInterval);

        // Set imported number of pings value.
        spnNumberOfPings.setValue(numOfPings);

        // Set continuous pinging flag to imported value.
        chkContinuousPinging.setSelected(continuousPinging);

        // If the checkbox is selected.
        if (chkContinuousPinging.isSelected()) {
            // Gray out the spinner used to select the number of pings to indicate that this field no longer applies.
            lblNumberOfPings.setForeground(ValidationUtils.GRAYED_OUT_COLOR);
            // Disable the user from being able to change the value of the spinner.
            spnNumberOfPings.setEnabled(false);

            // If the check box is unselected.
        } else {
            // Return the spinner to default colour.
            lblNumberOfPings.setForeground(ValidationUtils.NORMAL_TEXT_COLOR);
            // Enable the user to be able to change the value of the spinner.
            spnNumberOfPings.setEnabled(true);
        }

        // Clear the tables.
        DefaultTableModel devicePingTableModel = (DefaultTableModel) tblDevicePing.getModel();
        DefaultTableModel devicePingResponseResultsTableModel = (DefaultTableModel) tblDevicePingResponseResults.getModel();
        DefaultTableModel devicePingPacketResultsTableModel = (DefaultTableModel) tblDevicePingPacketResults.getModel();

        devicePingTableModel.setRowCount(0);
        devicePingResponseResultsTableModel.setRowCount(0);
        devicePingPacketResultsTableModel.setRowCount(0);

        // Import the results from the file into the table.
        for (DevicePingResult devicePingResult : devicePingResults) {
            devicePingTableModel.addRow(new Object[]{
                ipAddress,
                devicePingResult.getRoundTripTime(),
                devicePingResult.isSuccessfulPing(),
                devicePingResult.getPacketLoss()
            });
        }

        // Update the device ping object
        devicePing = new DevicePing(ipAddress, pingInterval, numOfPings, continuousPinging, tblDevicePing, tblDevicePingResponseResults, tblDevicePingPacketResults);
        // Load the imported results into the new object.
        devicePing.setDevicePingResults(devicePingResults);

        // Set counter variables.
        devicePing.setPingCount();
        devicePing.setSuccessfulPings();

        // Update results tables.
        devicePing.populateResultsTables();

        // Reset button text.
        btnStartDevicePing.setText("Start Device Ping");
        // Set status message.
        lblDevicePingInProgress.setText("Results imported successfully.");
    }

    /**
     * Callback invoked when port scan results have been imported from a file.
     * <p>
     * This method stops any ongoing scan, displays the Port Scan panel,
     * populates the UI controls with imported parameters, loads the results
     * into the table, and resets the UI to reflect a completed import state.
     * </p>
     *
     * @param ipAddress the target IP address used in the imported scan
     * @param bottomRangePort the starting port of the imported scan range
     * @param topRangePort the ending port of the imported scan range
     * @param timeout the timeout value (ms) used in the imported scan
     * @param portScanResults the list of imported PortScanResult objects
     */
    @Override
    public void onPortScanResultsImported(String ipAddress, int bottomRangePort, int topRangePort, int timeout, ArrayList<PortScanResult> portScanResults) {
        // If a port scan is currently running, request it to stop immediately.
        if (portScanThread != null && portScanThread.isAlive() && portScan != null) {
            portScan.requestStop();
            portScan.shutDownExecutorService();
            portScanThread.interrupt();
        }

        // Show the port scan card.
        card.show(pnlMainPanel, "cardPortScan");
        // Remember that TCP messaging was not last used.
        tcpMessageLast = false;

        // Clear previous IP address error markers.
        txfIPAddressPortScan.setBackground(Color.WHITE);
        lblIPAddressErrorPortScan.setText("");
        // Set imported IP address.
        txfIPAddressPortScan.setText(ipAddress);

        // Set imported bottom range port.
        spnBottomRangePort.setValue(bottomRangePort);

        // Set imported top range port.
        spnTopRangePort.setValue(topRangePort);

        // Clear previous port range error markers.
        lblPortRangeError.setText("");

        // Set imported timeout.
        spnTimeoutPortScan.setValue(timeout);

        // Clear the table.
        DefaultTableModel model = (DefaultTableModel) tblPortScan.getModel();
        model.setRowCount(0);

        // Import the results from the file into the table.
        for (PortScanResult portScanResult : portScanResults) {
            model.addRow(new Object[]{
                portScanResult.getPortNumber(),
                portScanResult.getProtocol()
            });
        }

        // Update the port scan object.
        portScan = new PortScan(ipAddress, bottomRangePort, topRangePort, timeout, tblPortScan, prgPortScan);
        // Load the imported results into the new object.
        portScan.setPortScanResults(portScanResults);

        // Reset button text.
        btnStartPortScan.setText("Start Port Scan");
        // Set status message.
        lblPortScanInProgress.setText("Results imported successfully.");

        // Update progress bar.
        prgPortScan.setValue(100);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnDevicePing;
    private javax.swing.JButton btnExportResultsDevicePing;
    private javax.swing.JButton btnExportResultsPortScan;
    private javax.swing.JButton btnExportResultsSubnetScan;
    private javax.swing.JButton btnExportResultsTCPMessageConnect;
    private javax.swing.JButton btnExportResultsTCPMessageListen;
    private javax.swing.JButton btnImportResults;
    private javax.swing.JButton btnPortScan;
    private javax.swing.JButton btnSendTCPMessageConnect;
    private javax.swing.JButton btnSendTCPMessageListen;
    private javax.swing.JButton btnStartDevicePing;
    private javax.swing.JButton btnStartPortScan;
    private javax.swing.JButton btnStartSubnetScan;
    private javax.swing.JButton btnStartTCPMessageConnect;
    private javax.swing.JButton btnStartTCPMessageListen;
    private javax.swing.JButton btnSubnetScan;
    private javax.swing.JButton btnTCPMessage;
    private javax.swing.JButton btnTCPMessageConnect;
    private javax.swing.JButton btnTCPMessageListen;
    private javax.swing.JCheckBox chkContinuousPinging;
    private javax.swing.JLabel lblContinuousPinging;
    private javax.swing.JLabel lblDash;
    private javax.swing.JLabel lblDevicePing;
    private javax.swing.JLabel lblDevicePingInProgress;
    private javax.swing.JLabel lblEnterMessageTCPMessageConnect;
    private javax.swing.JLabel lblEnterMessageTCPMessageListen;
    private javax.swing.JLabel lblIPAddressDevicePing;
    private javax.swing.JLabel lblIPAddressErrorDevicePing;
    private javax.swing.JLabel lblIPAddressErrorPortScan;
    private javax.swing.JLabel lblIPAddressErrorTCPMessageConnect;
    private javax.swing.JLabel lblIPAddressTCPMessageConnect;
    private javax.swing.JLabel lblIPAdressPortScan;
    private javax.swing.JLabel lblNetworkRange;
    private javax.swing.JLabel lblNetworkRangeError;
    private javax.swing.JLabel lblNetworking;
    private javax.swing.JLabel lblNoTabsOpen;
    private javax.swing.JLabel lblNumberOfPings;
    private javax.swing.JLabel lblPingInterval;
    private javax.swing.JLabel lblPortRange;
    private javax.swing.JLabel lblPortRangeError;
    private javax.swing.JLabel lblPortScan;
    private javax.swing.JLabel lblPortScanInProgress;
    private javax.swing.JLabel lblPortTCPMessageConnect;
    private javax.swing.JLabel lblPortTCPMessageListen;
    private javax.swing.JLabel lblSubnetScan;
    private javax.swing.JLabel lblSubnetScanInProgress;
    private javax.swing.JLabel lblTCPMessageConnect;
    private javax.swing.JLabel lblTCPMessageConnectInProgress;
    private javax.swing.JLabel lblTCPMessageListen;
    private javax.swing.JLabel lblTCPMessageListenInProgress;
    private javax.swing.JLabel lblTimeoutPortScan;
    private javax.swing.JLabel lblTimeoutSubnetScan;
    private javax.swing.JLabel lblTitle;
    private javax.swing.JPanel pnlDevicePing;
    private javax.swing.JPanel pnlHomePage;
    private javax.swing.JPanel pnlLine1;
    private javax.swing.JPanel pnlMainPanel;
    private javax.swing.JPanel pnlPortScan;
    private javax.swing.JPanel pnlSideBar;
    private javax.swing.JPanel pnlSubnetScan;
    private javax.swing.JPanel pnlTCPMessageConnect;
    private javax.swing.JPanel pnlTCPMessageListen;
    private javax.swing.JProgressBar prgPortScan;
    private javax.swing.JProgressBar prgSubnetScan;
    private javax.swing.JScrollPane scrDevicePing;
    private javax.swing.JScrollPane scrDevicePingPacketResults;
    private javax.swing.JScrollPane scrDevicePingResponseResults;
    private javax.swing.JScrollPane scrPortScan;
    private javax.swing.JScrollPane scrSubnetScan;
    private javax.swing.JScrollPane scrTCPMessageConnect;
    private javax.swing.JScrollPane scrTCPMessageListen;
    private javax.swing.JSpinner spnBottomRangePort;
    private javax.swing.JSpinner spnNumberOfPings;
    private javax.swing.JSpinner spnPingInterval;
    private javax.swing.JSpinner spnPortTCPMessageConnect;
    private javax.swing.JSpinner spnPortTCPMessageListen;
    private javax.swing.JSpinner spnTimeoutPortScan;
    private javax.swing.JSpinner spnTimeoutSubnetScan;
    private javax.swing.JSpinner spnTopRangePort;
    private javax.swing.JTable tblDevicePing;
    private javax.swing.JTable tblDevicePingPacketResults;
    private javax.swing.JTable tblDevicePingResponseResults;
    private javax.swing.JTable tblPortScan;
    private javax.swing.JTable tblSubnetScan;
    private javax.swing.JTextField txfIPAddressDevicePing;
    private javax.swing.JTextField txfIPAddressPortScan;
    private javax.swing.JTextField txfIPAddressTCPMessageConnect;
    private javax.swing.JTextField txfMessageTCPMessageConnect;
    private javax.swing.JTextField txfMessageTCPMessageListen;
    private javax.swing.JTextField txfNetworkRange;
    private javax.swing.JTextPane txpTCPMessageConnect;
    private javax.swing.JTextPane txpTCPMessageListen;
    // End of variables declaration//GEN-END:variables
}
